input {
	beats {
		port => "5044"
	}
}

filter{
        grok{
            pattern_definitions => {
                "REQUEST" => "(Outgoing response|Incoming request)"
                "REQUEST_TYPE" => "(POST|GET)"
            }
            match => {"message" => [
                '^%{TIMESTAMP_ISO8601:zeit}%{SPACE}%{LOGLEVEL}%{SPACE}\[%{NOTSPACE:sessionid}\]\t\[%{NOTSPACE}\]\t\[%{NOTSPACE:userid}\]\t\[%{NOTSPACE} %{NOTSPACE}\]\t%{REQUEST:request}:%{SPACE}%{REQUEST_TYPE:request_type}%{SPACE}%{URIPATH:url}%{GREEDYDATA:stuff}',
                '^%{TIMESTAMP_ISO8601:zeit}%{GREEDYDATA:entry}'
                ]
            }
            remove_field => ['message']
        }

        if [url] !~ "\S+/rest" {
            drop{ }
        }

        mutate {
            gsub => [ "url", "\S+/rest", ""]
            remove_field => ['host','agent','@version','ecs','version']
        }

        date {
            match => [ "zeit", "ISO8601" ]
            target => "@timestamp"
		}

        if [request] == "Outgoing response"{
            drop { }
        }

        if [url] =~ "/fx/\S+" {
            mutate {
                gsub => ["url","/fx/\S+","/fx"]
            }
        }


#        aggregate {
#            task_id => "%{url}"
#            code => "map['counter'] ||=0; map['counter'] +=1;"
#            map_action => "create"
#            end_of_task => true
#        }
}

output {
    elasticsearch { hosts => ["localhost:9200"] }
    stdout { codec => rubydebug }
}